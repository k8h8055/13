<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_collision_p</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-164</depth>
  <persistent>-1</persistent>
  <parentName>O_Player_P</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 이미지 변수 
spr_index = spr_Char_mx;

img_index_max = 3;

img_speed = 0.2;

img_index = 0;

eff_delay = 0;

xscale = 1;
_jump_xscale = 1;
yscale = 1;

MyWeapon = instance_create(x,y,O_Player_Stick);
MyWeapon.MyMaster = self;

instance_create(x,y,O_Player_target);

_Damage = 0;

rot = 0;
character = global.select_menu;

spr_mx_sprite = spr_Char_mx;
spr_move_sprite = spr_Char_move;
spr_attack_sprite = spr_Char_attack;
spr_move_attack_sprite = spr_Char_move;
spr_jump_sprite = spr_Char_jump;
spr_jump_attack_sprite = spr_Char_jump;
spr_damage_sprite = spr_Char_damage;
_attackings = 0;

damage_image_delay = 0;
Damage_xscale = 1;

_depth = -154;

_die_sound = 0;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 공격,이동 펄스 변수

DIRECTION = 0;
DIRECTION_MAX = 0;
DIRECTION_Y = 0;
DIRECTION_Y_MAX = 0;
DIRECTION_ON = 0;
DIRECTION_X = 0;
DIRECTION_X_MAX = 0;
DIRECTION_X_ON = 0;

M_FALSE = 0;
_att = 0;
_ATTACKING = 0;
_ATTACK = 0;
_ATTACK_1 = 0;
_ATTACK_2 = 0;
_ATTACK_MAGIC = 0;
_ATTACK_MAGIC_B = 0;
_ATTACK_MAGICING = 0;

_ATTACK_POSITION = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_speed = 0.5;

facing = image_xscale; // Change xscale in editor to adjust initial facing

_spr = sprite_index;

// For squash + stretch
///////////////////////////////////////////////////////////////////////////////

// Misc ///////////////////////////////////////////////////////////////////////

mDir = 1;
// Relative collision checks
cLeft  = 0;
cRight = 0;
ccLeft  = 0;
ccRight = 0;
cAbove = 0;
cHide = 0;
cClimb_Left = 0;
cClimb_Right = 0;

_xspd = 0;
_yspd = 0;

m_dir = 0;

m_Brake = 0;
onGround = false;
platformTarget = false;
onWaters = false;
_Jump = 0;
// Adjust THIS to adjust overall player speed
m = 0.25;

// Acceleration + friction
groundAccel = 0.5//  * m;
groundFric  = 1.0//  * m;
airAccel    = 0.5// * m;
airFric     = 0.1// * m;

// Max movement speeds
maxH        = global._Pspeed//12  * m;
maxV        = 16//30.0  * m;
mAccel = 0;

_frictionTarget = noone;
_frictionXTarget = noone;

_bac_delay = 0;
_moving = 0;
_Jumping = 0;

_booster = 0;

_room_start_position = -1;

onUpGround = OnUpGround(0);
onWater = OnWater(0);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>301</id>
        <kind>0</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_set_alarm</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>1</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 물체 점프 변수
_JumpBlock = 0;
_Down_Jump = 0;
jumpHeight  = 25//25  * m;
jumpHeight_c = jumpHeight;
jumpWidth   = 0;
gravRise    = 0.6//3  * m;
gravFall    = 0.6//3  * m;
gravSlide   = 0.3// * m;
Slide = false;
camDist     = 6//24.0; // (later versions)

// Frames prior to being able to push off of wall slide with arrow keys (doesn't affect wall jump)
clingTime   = 4//4.0  * m;

kJump = false;

onGround_scale = 1;

lqd     = 0;
prvlqd  = 0;
slqd    = 0;
sprvlqd = 0;
splashdelay = 4;

v = 5;

jumpByGround = false;

Empty_Jump_check = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>_yspd = 10;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>character_hair = 0;
switch(character)
{
case 0 :
spr_mx_sprite = spr_Char_mx;
spr_move_sprite = spr_Char_move;
spr_move_attack_sprite = spr_Char_move;
spr_attack_sprite = spr_Char_attack;
spr_jump_sprite = spr_Char_jump;
spr_jump_attack_sprite = spr_Char_jump;
spr_damage_sprite = spr_Char_damage;
break;
case 1 :
spr_mx_sprite = spr_Char_mx_1;
spr_move_sprite = spr_Char_move_1;
spr_move_attack_sprite = spr_Char_move_attack_1;
spr_attack_sprite = spr_Char_attack_1;
spr_jump_sprite = spr_Char_jump_1;
spr_jump_attack_sprite = spr_Char_jump_attack_1;
spr_damage_sprite = spr_Char_mx_1;
break;
case 2 :
spr_mx_sprite = spr_Char_mx_2;
spr_move_sprite = spr_Char_move_2;
spr_move_attack_sprite = spr_Char_move_2;
spr_attack_sprite = spr_Char_attack_2;
spr_jump_sprite = spr_Char_jump_2;
spr_jump_attack_sprite = spr_Char_jump_2;
spr_damage_sprite = spr_Char_mx_2;
break;
case 3 :
spr_mx_sprite = spr_Char_mx_3;
spr_move_sprite = spr_Char_move_3;
spr_move_attack_sprite = spr_Char_move_3;
spr_attack_sprite = spr_Char_attack_3;
spr_jump_sprite = spr_Char_jump_3;
spr_jump_attack_sprite = spr_Char_jump_3;
spr_damage_sprite = spr_Char_mx_3;
break;
case 4 :
spr_mx_sprite = spr_Char_mx_4;
spr_move_sprite = spr_Char_move_4;
spr_move_attack_sprite = spr_Char_move_4;
spr_attack_sprite = spr_Char_attack_4;
spr_jump_sprite = spr_Char_jump_4;
spr_jump_attack_sprite = spr_Char_jump_4;
spr_damage_sprite = spr_Char_mx_4;
break;
case 5 :
spr_mx_sprite = spr_Char_mx_5;
spr_move_sprite = spr_Char_mx_5;
spr_move_attack_sprite = spr_Char_mx_5;
spr_attack_sprite = spr_Char_attack_5;
spr_jump_sprite = spr_Char_mx_5;
spr_jump_attack_sprite = spr_Char_mx_5;
spr_damage_sprite = spr_Char_mx_5;
break;
}

if !instance_exists(OBJ_Inv_UI){
instance_create(view_xview+view_wview/2,view_yview+view_hview/2,OBJ_Inv_UI);
instance_create(view_xview+view_wview/2,view_yview+view_hview/2,OBJ_CHAR_UI);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 불빛

if instance_exists(OBAC_NIGHT){
surface_set_target(OBAC_NIGHT.screen);

draw_set_blend_mode(bm_subtract);
draw_sprite_ext(spr_round_light, 0, x - view_xview, y - view_yview, 7, 7, 0, c_white, 1);
draw_set_blend_mode(bm_normal);

surface_reset_target();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Collision</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>612</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if_variable</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>global.inventory_on</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>-1</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 이동 함수 
// Actual collision checks + movement
// Vertical

var onPlayOnGround = OnPlayOnGround(_yspd,self);
var onPlayByEGround = OnPlayByEGround(_xspd,_yspd);
var onPlayByGround = OnPlayByGround(_xspd,onGround_scale);
var onPlayByGrounds =  OnPlayByGrounds(_xspd,onGround_scale);

//jumpByGround = collision_line(x-sprite_width/2 - 4 -_xspd*2,y,x+sprite_width/2 + 4 -_xspd*2,y+sprite_height/2,O_Block_Parent,1,0) 
//|| collision_line(x-sprite_width/2-_xspd*2,y,x+sprite_width/2-_xspd*2,y+sprite_height/2+4,O_Block_empty_parent,1,0);

jumpByGround = collision_rectangle(x - sprite_width/2,y,x+sprite_width/2,y+36,O_Block_Parent,1,0) || collision_rectangle(x - sprite_width/2,y,x+sprite_width/2,y+36,O_Block_empty_parent,1,0);


repeat(abs(_yspd)){
    if (onPlayOnGround)
    {
    y += sign(_yspd);
    }
    else{
    if (place_meeting(x, y + 1, O_Block_empty_parent)) &amp;&amp; _yspd &gt;= 0{
    if Empty_Jump_check == 0{
    _jump_xscale = 1.3;
    yscale = 0.7;
    Empty_Jump_check = 1;
    }
    _yspd = 0;
    break; 
    }
    else if !place_meeting(x, y + sign(_yspd), O_Block_Parent)
        {
        y += sign(_yspd);
        cHide = true;
        Empty_Jump_check = 0;
        }
    else {
    OnFloater(_yspd,self);
    cHide = false;       
        // Move bridge
        if (instance_place(x, y + sign(_yspd) , oBridgeSegment)) {
            with (instance_place(x, y + sign(_yspd) , oBridgeSegment))
                {
                //phy_linear_velocity_y = other._yspd * 10;
                }
        } else{   
            if place_meeting(x, y - abs(sign(_yspd)), O_Block_Parent){
            y += abs(sign(_yspd));
            }
            if _yspd !=0{
            _jump_xscale = 1.3;
            yscale = 0.7;
            }
            _yspd = 0;
        
            }
        break;
    }
    }
}

// Horizontal
var tempH = _xspd;

repeat(abs(_xspd)){
OnPlayBridge(_xspd,onGround_scale);


    // Bridge
       /*
            // 5 pixel bridge slope
            if (place_meeting(x + sign(_xspd), y - 4 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd), y - 3 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd), y - 2 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd), y - 1 , O_Block_Parent)) {
                if (!place_meeting(x + sign(_xspd), y - 5 , O_Block_Parent))
                    {y -= 5;}
            }
            
            // 4 pixel bridge slope
            if (place_meeting(x + sign(_xspd), y - 3 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd), y - 2 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd), y - 1 , O_Block_Parent)) {
                if (!place_meeting(x + sign(_xspd), y - 4 , O_Block_Parent))
                    {y -= 4;}
            }
            
            // 3 pixel bridge slope
            if (place_meeting(x + sign(_xspd), y - 2 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd), y - 1 , O_Block_Parent)) {
                if (!place_meeting(x + sign(_xspd), y - 3 , O_Block_Parent))
                    {y -= 3;}
            }
        
    
    // End bridge   
    
    // UP slope
    if (place_meeting(x + sign(_xspd), y , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd), y - 1 , O_Block_Parent) &amp;&amp; !(place_meeting(x + sign(_xspd), y - 2 , O_Block_Parent))) {
        y -= 2;
    } else if (place_meeting(x + sign(_xspd), y , O_Block_Parent) &amp;&amp; !place_meeting(x + sign(_xspd), y - 1 , O_Block_Parent)) {
        --y;
    }
    
    // DOWN slope
    if (!place_meeting(x + sign(_xspd), y , O_Block_Parent) &amp;&amp; !place_meeting(x + sign(_xspd), y + 1 , O_Block_Parent) &amp;&amp; !place_meeting(x + sign(_xspd), y + 2 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd), y + 3 , O_Block_Parent))
        {y += 2;}
    else if (!place_meeting(x + sign(_xspd), y , O_Block_Parent) &amp;&amp; !place_meeting(x + sign(_xspd), y + 1 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd), y + 2 , O_Block_Parent))
        {++y;}
*/
if (onPlayByEGround)
{
M_FALSE = 0;  
        if x &gt; room_width - sprite_width/2 - (sign(_xspd)*2){
        x -= sign(abs(_xspd))
        }else{
        if x &lt; sprite_width/2 + (sign(_xspd)){
        x += sign(abs(_xspd))
        }           
        else{
        if !(onPlayByGround){
        if !instance_place(x+sign(_xspd) * 3,y+sign(_yspd) - 1,O_Block_Parent)
        || instance_place(x+sign(_xspd),y+sign(_yspd),oBridgeSegment)    
        x += sign(_xspd); 
        else
        x -= sign(_xspd)*2; 
        }
        }
        }
}
else{
    if !(onPlayByGround)
    {      
    M_FALSE = 0;  
        if x &gt; room_width - sprite_width/2 - (sign(_xspd)*2){
        x -= sign(abs(_xspd))
        }else if x &lt; sprite_width/2 + (sign(_xspd) * 2){
        x += sign(abs(_xspd))
        }          
        else{
        if (onGround) || (!(onGround)){ 
        if !instance_place(x+sign(_xspd) * 3,y+sign(_yspd) - 1,O_Block_Parent)
        || instance_place(x+sign(_xspd)*2,y+sign(_yspd),oBridgeSegment)        
        x += sign(_xspd); 
        //if _Jump &gt;0{x -= (sign(_xspd)/80);}
        }
        }    
        }
    else {
        M_FALSE = 1;
if !(place_meeting(x + sign(_xspd) + (xscale * 2), y, oBridgeSegment)){
        x -= sign(_xspd)*2;
        }
        _xspd = 0;
        break;
    }  
    }
}

if eff_delay == 0 &amp;&amp; _booster &gt; 20{
        eff = instance_create(x,y,O_Player_eff);
        eff.sprite_index = spr_index;
        eff.image_index = img_index;
        eff.image_xscale = xscale;
        eff_delay = 4;
        }else{
        if eff_delay &gt; 0{eff_delay -= 1;}
        }
        
if !(place_meeting(x, y + 5, oBridgeSegment)){
DIRECTION_Y = 0;
}

        /*
if !(place_meeting(x + (onGround_scale * sprite_width/2), y + 30, oBridgeSegment)) {
if DIRECTION_X &gt; 0 &amp;&amp; _ATTACKING &lt;= 0{DIRECTION_X -= 0.5;}
DIRECTION_X_MAX = 0;
}
if DIRECTION_X &lt; DIRECTION_X_MAX{DIRECTION_X += 1;DIRECTION_X_ON = 0;}
if DIRECTION_X &gt; 0{DIRECTION_X_ON = 0;}else{DIRECTION_X_ON = 1;}
if DIRECTION &gt; 0{DIRECTION_ON = 1;}
else 
DIRECTION_ON = 0;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var temp;

// Check if you were onGround previous frame
temp = onGround;

//if onGround{
if _xspd &lt; 0 == true
onGround_scale = -1;
if _xspd &gt; 0 == true
onGround_scale = 1;
else
onGround_scale = 0;
//}

onGround = OnGround(onGround_scale);
onWater = OnWater(onGround_scale);
onUpGround = OnUpGround(onGround_scale);

if onWater &amp;&amp; !(_booster &gt; 0){
gravRise    = 0.2//3  * m;
gravFall    = 0.2//3  * m;
gravSlide   = 0.05// * m;
jumpHeight  = 4//25  * m;
jumpHeight_c = jumpHeight;
}else{
gravRise    = 0.6//3  * m;
gravFall    = 0.6//3  * m;
gravSlide   = 0.3// * m;
jumpHeight  = 11//25  * m;
jumpHeight_c = jumpHeight;
}
//if onGround{_yspd = 0};
//onWater = OnWater();
platformTarget = instance_place(x, y + 1/4, O_Block_Parent);

// Squash sprite during jump landing
if (!temp &amp;&amp; onGround) {
    if (_yspd &gt;= 0) {        
        //yscale = 0.66;
        //xscale = 1.33;  
    }
}
if global._hp &gt; 0{
if _Damage &gt; 80{
if damage_image_delay == 0{
randomize();
audio_play_sound(choose(s_ouch_8,s_ouch_6,s_ouch_5,s_ouch_4,s_ouch_3,s_ouch_2),0,0);
}
if damage_image_delay &lt; 30{
image_blend = c_red;//make_colour_rgb(255,90,90);
damage_image_delay += 1;
}
else{
image_blend = c_white;
}
if xscale == 1 &amp;&amp; Damage_xscale != xscale{
rot += (44-rot)/10;
}
else if xscale == 1 &amp;&amp; Damage_xscale == xscale{
rot += (-44-rot)/10;
}

if xscale == -1 &amp;&amp; Damage_xscale != xscale{
rot += (-44-rot)/10;
}
else if xscale == -1 &amp;&amp; Damage_xscale == xscale{
rot += (44-rot)/10;
}

_xspd += (0-_xspd)/30;
}else{
damage_image_delay = 0;
if !(image_blend == c_white){
image_blend = c_white;
}
}

if _attackings &gt; 0 || _Damage &lt;= 30{
rot += (0-rot)/30;
}
if _Damage &gt; 0{_Damage -= 1;}
}
else{
if _die_sound == 0{
audio_play_sound(s_ouch_9,0,0);
_die_sound = 1;
}
global._hp = 0;
_xspd += (0-_xspd)/10;
if xscale == 1{
if rot &lt; 90{
rot += (90 - rot)/10;
}
}else{
if rot &gt; -90{
rot += (-90 - rot)/10;
}
}
image_blend = c_white;
//depth = -300;
if (_die_sound &lt; 240){
_die_sound += 1;
}
else{
game_restart();
}
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 이미지 컨트롤 
if spr_index == spr_damage_sprite{
img_index_max = 0;
img_speed = 0;
}
if spr_index == spr_mx_sprite{
img_index_max = 0;
img_speed = 0;
}
if spr_index == spr_move_sprite || spr_index == spr_move_attack_sprite{
img_index_max = 7;
img_speed = 0.15 * abs(_xspd/2);
}
if spr_index == spr_jump_sprite 
|| spr_index = spr_jump_attack_sprite{
img_index_max = 5;
img_speed = 0.2 + 0.1 * (abs(_yspd/2) + abs(_xspd/2));
}
if spr_index == spr_attack_sprite{img_index_max = 0;img_speed = 0;}

if (global.inventory_on == -1){
if img_index &lt; img_index_max{
img_index += img_speed;
}
else if img_index &gt;= img_index_max{
img_index = 0;
}
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 드로우 
if _Damage &gt;= 60 || global._hp &lt;= 0{
spr_index = spr_damage_sprite;
}
else if !onGround &amp;&amp; (((!onUpGround)) || (_Down_Jump = 1)) &amp;&amp; !(jumpByGround)
{
if _attackings &gt; 0
spr_index = spr_jump_attack_sprite;
else
spr_index = spr_jump_sprite;
}
else if (O_PAD._M_Left == true || O_PAD._M_Right == true) &amp;&amp; (jumpByGround || onGround || (onUpGround &amp;&amp; _Jump &lt;= 0))
&amp;&amp; _Down_Jump = 0 &amp;&amp; _Damage &lt;= 60{
if (O_Player_Stick._attack_Delay &gt; 0 || O_Player_Stick._attack_Delay_2 &gt; 0 || _attackings &gt; 0){
spr_index = spr_move_attack_sprite;
}
else{
spr_index = spr_move_sprite;
}
}
else if O_Player_Stick._attack_Delay &gt; 0 || O_Player_Stick._attack_Delay_2 &gt; 0{
spr_index = spr_attack_sprite;
}
else if (abs(_xspd) &lt; 1 &amp;&amp; (onGround || onUpGround) || _Damage &gt; 60) &amp;&amp; _yspd == 0{
if _attackings &gt; 0
spr_index = spr_attack_sprite;
else
spr_index = spr_mx_sprite;
//_Down_Jump = 0;
}

if _attackings &gt; 0 {
_attackings -= 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>612</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if_variable</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>global.inventory_on</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>-1</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Update relative collision

maxH = global._Pspeed;

cLeft  = place_meeting(x - 1, y, O_Block_Parent); 
cRight = place_meeting(x + 1, y, O_Block_Parent); 
cAbove = place_meeting(x, y - 1, O_Block_Parent);
//var kJump = mouse_check_button_pressed(mb_right);

if ((onGround) || (onUpGround &amp;&amp; _yspd &gt;= 0) || onWater) &amp;&amp; _ATTACKING == 0{
if onWater{
if _Jump &gt;0{_moving = 5;_Jump -= 0.4;};
}else{
if _Jump &gt;0{_moving = 5;_Jump -= 4;};}
}
if m_Brake &gt; 0{
if _Jump &lt;=0
_xspd += (0-_xspd)/10;
else
_xspd += (0-_xspd)/20;

if m_Brake &gt;= 30{image_index = 0;}
m_Brake -= 1;
}

if Slide = false &amp;&amp; (_ATTACKING &gt;= 4 || _ATTACKING &lt;= 0) &amp;&amp; _Damage &lt;= 60
{
if (_Jump &gt;= 5){_Jump = 4}
if O_PAD._M_Left == true{
    m_dir = -1;
    if _moving &lt; 5{_moving +=1;}}
else if O_PAD._M_Right == true
{
        m_dir = 1;
        if _moving &lt; 5{_moving +=1;}}
else{
if m_Brake &lt;=0{

if _booster &gt; 0 &amp;&amp; _booster &lt; 30{
    _xspd += (0-_xspd)/15;
    }
    else if _booster &lt;= 0{
    _xspd = 0;
    }
    
    
    }
    if _Jump &lt;= 0{m_dir = 0;}
    if _moving &gt;0{_moving -=1}
    }
}
if global._hp &gt; 0{
if O_Player_target.x &gt; x{xscale = 1;}
if O_Player_target.x &lt; x{xscale = -1;}
}
if (!onGround &amp;&amp; (cLeft || cRight)){
/*
if instance_exists(_frictionTarget){
if _frictionTarget._friction &gt; 0{
Slide = true;

//_yspd = _frictionTarget._friction / 4;
}
else{
if ((cLeft || cRight) &amp;&amp; _yspd &gt;= 0) {
        // Wall slide
        _yspd = Approach(_yspd, maxV, gravSlide);
    } else {
        
        // Fall normally
        if (_yspd &lt; 0)
            _yspd = Approach(_yspd, maxV, gravRise);
        else
            _yspd = Approach(_yspd, maxV, gravFall);
    }
}
}
*/
}
else{
Slide = false;
if (!onGround){
    if ((cLeft || cRight) &amp;&amp; _yspd &gt;= 0) {
        // Wall slide
        _yspd = Approach(_yspd, maxV, gravSlide);
    } else {
        
        // Fall normally
        if (_yspd &lt; 0)
            _yspd = Approach(_yspd, maxV, gravRise);
        else
            _yspd = Approach(_yspd, maxV, gravFall);
    }
}
}
if (!((cLeft) &amp;&amp; (cRight))){

if (O_PAD._M_Left == true || O_PAD._M_Right == true) &amp;&amp; _booster &lt;= 30 &amp;&amp; m_Brake &lt;= 0 &amp;&amp; _Damage &lt;= 60{
if jumpWidth &lt;=0{
if _xspd &gt; m_dir * maxH &amp;&amp; m_dir == 1{
_xspd -= 1;
}
else if _xspd &lt; m_dir * maxH &amp;&amp; m_dir == -1{
_xspd += 1;
}
else{
_xspd = m_dir * maxH;

}
}else if jumpWidth &gt; 0{
if _xspd &gt; m_dir * maxH &amp;&amp; m_dir == 1{
_xspd -= 1;
}
else if _xspd &lt; m_dir * maxH &amp;&amp; m_dir == -1{
_xspd += 1;
}
else{
_xspd = m_dir * maxH;
}
jumpWidth -= 0.01;
}
}
}
if _booster &gt; 0 &amp;&amp; _Damage &lt;= 60{
if _booster &gt;= 30{
_xspd += ((m_dir * maxH) - _xspd)/10;
//_yspd = (maxV - _yspd)/10;
}
if _booster == 1{
with(O_Player_Clone){
if _booster &lt;=0{
if onGround{
_booster = 38;
}else{
_booster = 38;
}

if (onWater &amp;&amp; !(_booster &gt; 0)){
gravRise    = 0.2//3  * m;
gravFall    = 0.2//3  * m;
gravSlide   = 0.05// * m;
jumpHeight  = 4//25  * m;
jumpHeight_c = jumpHeight;
}else{
gravRise    = 0.6//3  * m;
gravFall    = 0.6//3  * m;
gravSlide   = 0.3// * m;
jumpHeight  = 10//25  * m;
jumpHeight_c = jumpHeight;
}

m_Brake = 0;
var point_target = point_direction(x,y,O_Player.x,O_Player.y);
_xspd = lengthdir_x(64,point_target);

if (-(jumpHeight * 1.8) &gt; -lengthdir_y(64,point_target)){
_yspd = jumpHeight * 1.8;
}
else{
if (-(jumpHeight * 1.8) &gt; lengthdir_y(64,point_target)){
_yspd = -(jumpHeight * 1.8);
}
else{
_yspd = lengthdir_y(64,point_target);
}
}
}
}
}
if _xspd &gt; m_dir * maxH &amp;&amp; m_dir == 1{
//_xspd -= 1;
}
if _xspd &lt; m_dir * maxH &amp;&amp; m_dir == -1{
//_xspd += 1;
}

_booster -= 1;
}
if ((kJump) &amp;&amp; _Jump &lt;= 0 &amp;&amp; _Damage &lt;= 60) || _JumpBlock == 1 {
_Jump = 5;image_speed = 0.6;image_index = 0;
_jump_xscale = 0.7;
yscale = 1.3;
if _Down_Jump == 1 &amp;&amp; _JumpBlock == 0{
y += 4;
}else{
_Down_Jump = 0;
_yspd = -jumpHeight * 1.2;
}
Slide = false;    
m_Brake = 0;
jumpHeight = jumpHeight_c;
_JumpBlock = 0;

kJump = false;
_Down_Jump = 0;
}

//if _yspd &lt;= 0 {

//}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///test liquid contact

    //find closest liquid box
    var obj  = instance_nearest_bbox(oWater);
    if instance_exists(obj){
    //collide with liquid
    lqd  = place_meeting(x, y, obj) &amp;&amp; !collision_rectangle(bbox_left, y, bbox_right, y + 96, oFloater, true, true) &amp;&amp; !place_meeting(x, y, oShallowWaterMask);
    slqd = place_meeting(x, y, oShallowWaterMask); 
    
    // Jump in water
    if (!slqd) {
    if (lqd != prvlqd) {
            //realise current liquid state
            prvlqd = lqd;
            
            //apply manipulation to liquid
            liquid_apply_force_x(obj, x, _yspd * 0.25);
            liquid_splash_create(obj, x, liquid_point_y(obj, x), -abs(_yspd * 0.5), 16, 8, 8, 0.25, c_white, 0.5, bm_normal);
            
            //speed up on liquid exit/slowdown on entrace
            if (!lqd) _yspd *= 1; else _yspd *= 0.5; 
            
        }
    }
    
    // Jump in shallow water
    if (slqd != sprvlqd)
    {
        //realise current liquid state
        sprvlqd = slqd;
    }    
    
    // Walk in shallow water
    if (slqd) {
        if (_xspd != 0) {
            liquid_apply_force_x(obj, x, _xspd * 0.25);
            if (--splashdelay &lt;= 0) {
                splashdelay = 6;
                liquid_splash_create(obj, x, liquid_point_y(obj, x), -abs(_xspd * 0.25), 4, 4, 4, 0.5, c_white, 0.5, bm_normal); 
            }       
        }
        
        if (_xspd != 0) {
            liquid_apply_force_x(obj, x, _xspd * 0.2);
            liquid_splash_create(obj, x, liquid_point_y(obj, x), -abs(_xspd * 0.2), 4, 4, 4, 0.5, c_white, 0.5, bm_normal);        
        }    
    }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>_jump_xscale += (1 - _jump_xscale)/10;
yscale += (1 - yscale)/10;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.room_number_on_n[global.room_numbers] = 2;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if _room_start_position == 0{
x = OBJ_NEXT_STAGE.x;
y = OBJ_NEXT_STAGE.y-16;
}
else if _room_start_position = 1{
x = OBJ_PREVIOUS_STAGE.x;
y = OBJ_PREVIOUS_STAGE.y-16;
}
else if _room_start_position = 2{
x = OBJ_DOWN_STAGE.x;
y = OBJ_DOWN_STAGE.y-16;
}
else if _room_start_position = 3{
x = OBJ_UP_STAGE.x;
y = OBJ_UP_STAGE.y-16;
}
else if instance_exists(OBJ_ROOM_START){
x = OBJ_ROOM_START.x;
y = OBJ_ROOM_START.y-16;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if global._hp &lt;= 0{
draw_sprite_ext(BAC_POP_DOWN,0,view_xview,view_yview,1,1,0,c_white,0.7);
draw_sprite_ext(spr_index,img_index,x, y+DIRECTION_Y+20,1*xscale*_jump_xscale, 1*yscale, rot, image_blend, image_alpha);   
}
else{
draw_sprite_ext(spr_index,img_index,x, y+DIRECTION_Y+32,1*xscale*_jump_xscale, 1*yscale, rot, image_blend, image_alpha);
}

//draw_set_font(font0)
//draw_text_colour(x,y,string(onGround_scale),c_red,c_red,c_red,c_red,1);
//draw_text_colour(x,y+30,string(_xspd),c_red,c_red,c_red,c_red,1);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="46">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global._hp = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="8">
      <action>
        <libid>1</libid>
        <id>331</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_restart_game</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
