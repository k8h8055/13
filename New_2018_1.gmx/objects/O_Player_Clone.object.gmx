<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_collision_p</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-151</depth>
  <persistent>-1</persistent>
  <parentName>O_Player_P</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 이미지 변수 
spr_index = spr_Char_mx;

img_index_max = 3;

img_speed = 0.2;

img_index = 0;

eff_delay = 0;

EnTarget = noone;

xscale = 1;
yscale = 1;

MyWeapon = instance_create(x,y,O_Player_Stick_Npc);
MyWeapon.MyMaster = self;

_Damage = 0;

rot = 0;
character = 0;

spr_mx_sprite = spr_Char_mx;
spr_move_sprite = spr_Char_move;
spr_attack_sprite = spr_Char_attack;
spr_move_attack_sprite = spr_Char_move;
spr_jump_sprite = spr_Char_jump;
spr_jump_attack_sprite = spr_Char_jump;

_attackings = 0;
_alp = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 공격,이동 펄스 변수

DIRECTION = 0;
DIRECTION_MAX = 0;
DIRECTION_Y = 0;
DIRECTION_Y_MAX = 0;
DIRECTION_ON = 0;
DIRECTION_X = 0;
DIRECTION_X_MAX = 0;
DIRECTION_X_ON = 0;

M_FALSE = 0;
_att = 0;
_ATTACKING = 0;
_ATTACK = 0;
_ATTACK_1 = 0;
_ATTACK_2 = 0;
_ATTACK_MAGIC = 0;
_ATTACK_MAGIC_B = 0;
_ATTACK_MAGICING = 0;

_ATTACK_POSITION = 0;

_M_Left = false;
_M_Right = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_speed = 0.5;

facing = image_xscale; // Change xscale in editor to adjust initial facing

_spr = sprite_index;

// For squash + stretch
///////////////////////////////////////////////////////////////////////////////

// Misc ///////////////////////////////////////////////////////////////////////

mDir = 1;
// Relative collision checks
cLeft  = 0;
cRight = 0;
ccLeft  = 0;
ccRight = 0;
cAbove = 0;
cHide = 0;
cClimb_Left = 0;
cClimb_Right = 0;

_xspd = 0;
_yspd = 0;

m_dir = 0;

m_Brake = 0;
onGround = false;
platformTarget = false;
onWaters = false;
_Jump = 0;
// Adjust THIS to adjust overall player speed
m = 0.25;

// Acceleration + friction
groundAccel = 0.5//  * m;
groundFric  = 1.0//  * m;
airAccel    = 0.5// * m;
airFric     = 0.1// * m;

// Max movement speeds
maxH        = 6//12  * m;
maxV        = 16//30.0  * m;
mAccel = 0;

_frictionTarget = noone;
_frictionXTarget = noone;

_bac_delay = 0;
_moving = 0;
_Jumping = 0;

_booster = 0;

_room_start_position = -1;

onUpGround = OnUpGround(0);
onWater = OnWater(0);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 물체 점프 변수
_JumpBlock = 0;
_Down_Jump = 0;
jumpHeight  = 10//25  * m;
jumpHeight_c = jumpHeight;
jumpWidth   = 0;
gravRise    = 0.6//3  * m;
gravFall    = 0.6//3  * m;
gravSlide   = 0.3// * m;
Slide = false;
camDist     = 6//24.0; // (later versions)

// Frames prior to being able to push off of wall slide with arrow keys (doesn't affect wall jump)
clingTime   = 4//4.0  * m;

kJump = false;

onGround_scale = 1;

lqd     = 0;
prvlqd  = 0;
slqd    = 0;
sprvlqd = 0;
splashdelay = 4;

v = 5;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>301</id>
        <kind>0</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_set_alarm</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>1</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>_yspd = 10;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>character_hair = 0;
switch(character)
{
case 0 :
spr_mx_sprite = spr_Char_mx;
spr_move_sprite = spr_Char_move;
spr_move_attack_sprite = spr_Char_move;
spr_attack_sprite = spr_Char_attack;
spr_jump_sprite = spr_Char_jump;
spr_jump_attack_sprite = spr_Char_jump;
break;
case 1 :
spr_mx_sprite = spr_Char_mx_1;
spr_move_sprite = spr_Char_move_1;
spr_move_attack_sprite = spr_Char_move_attack_1;
spr_attack_sprite = spr_Char_attack_1;
spr_jump_sprite = spr_Char_jump_1;
spr_jump_attack_sprite = spr_Char_jump_attack_1;
break;
case 2 :
spr_mx_sprite = spr_Char_mx_2;
spr_move_sprite = spr_Char_move_2;
spr_move_attack_sprite = spr_Char_move_2;
spr_attack_sprite = spr_Char_attack_2;
spr_jump_sprite = spr_Char_jump_2;
spr_jump_attack_sprite = spr_Char_jump_2;
break;
case 3 :
spr_mx_sprite = spr_Char_mx_3;
spr_move_sprite = spr_Char_move_3;
spr_move_attack_sprite = spr_Char_move_3;
spr_attack_sprite = spr_Char_attack_3;
spr_jump_sprite = spr_Char_jump_3;
spr_jump_attack_sprite = spr_Char_jump_3;
break;
case 4 :
spr_mx_sprite = spr_Char_mx_4;
spr_move_sprite = spr_Char_move_4;
spr_move_attack_sprite = spr_Char_move_4;
spr_attack_sprite = spr_Char_attack_4;
spr_jump_sprite = spr_Char_jump_4;
spr_jump_attack_sprite = spr_Char_jump_4;
break;
case 5 :
spr_mx_sprite = spr_Char_mx_5;
spr_move_sprite = spr_Char_mx_5;
spr_move_attack_sprite = spr_Char_mx_5;
spr_attack_sprite = spr_Char_attack_5;
spr_jump_sprite = spr_Char_mx_5;
spr_jump_attack_sprite = spr_Char_mx_5;
break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Collision</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>612</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if_variable</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>global.inventory_on</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>-1</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 이동 함수 
// Actual collision checks + movement
// Vertical

var onPlayOnGround = OnPlayOnGround(_yspd,self);
repeat(abs(_yspd)){
    if (onPlayOnGround)
    {
    y += sign(_yspd);
    }
    else{
    if (place_meeting(x, y + 1, O_Block_empty_parent)) &amp;&amp; _yspd &gt;= 0{
    _yspd = 0;
    break; 
    }
    else if (!place_meeting(x, y + sign(_yspd), O_Block_Parent))
        {
        y += sign(_yspd);
        cHide = true;
        }
    else {
    OnFloater(_yspd,self);
    cHide = false;       
        // Move bridge
        if (instance_place(x, y + sign(_yspd) , oBridgeSegment)) {
            with (instance_place(x, y + sign(_yspd) , oBridgeSegment))
                {
                //phy_linear_velocity_y = other._yspd * 10;
                }
        } else{    
            _yspd = 0;
            }
        break;
    }
    }
}

// Horizontal
var tempH = _xspd;

repeat(abs(_xspd)) {
var onPlayByEGround = OnPlayByEGround(_xspd,_yspd);
var onPlayByGround = OnPlayByGround(_xspd,onGround_scale);
var onPlayByGrounds =  OnPlayByGrounds(_xspd,onGround_scale);
OnPlayBridge(_xspd,onGround_scale);

/*
    // Bridge
    if (place_meeting(x + (onGround_scale * 1), y + 1 , oBridgeSegment)) {
        if (place_meeting(x + sign(_xspd) + (onGround_scale * 1), y , O_Block_Parent)) {
            // 5 pixel bridge slope
            if (place_meeting(x + sign(_xspd) + (onGround_scale * 1), y - 4 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd) + (onGround_scale * 1), y - 3 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd) + (onGround_scale * 1), y - 2 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd) + (onGround_scale * 1), y - 1 , O_Block_Parent)) {
                if (!place_meeting(x + sign(_xspd) + (onGround_scale * 1), y - 5 , O_Block_Parent))
                    {y -= 5;DIRECTION_MAX = 45;DIRECTION_Y_MAX = 1*10}
            }
            
            // 4 pixel bridge slope
            if (place_meeting(x + sign(_xspd) + (onGround_scale * 1), y - 3 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd) + (onGround_scale * 1), y - 2 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd) + (onGround_scale * 1), y - 1 , O_Block_Parent)) {
                if (!place_meeting(x + sign(_xspd) + (onGround_scale * 1), y - 4 , O_Block_Parent))
                    {y -= 4;DIRECTION_MAX = 40;DIRECTION_Y_MAX = 1*30}
            }
            
            // 3 pixel bridge slope
            if (place_meeting(x + sign(_xspd) + (onGround_scale * 1), y - 2 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd) + (onGround_scale * 1), y - 1 , O_Block_Parent)) {
                if (!place_meeting(x + sign(_xspd) + (onGround_scale * 1), y - 3 , O_Block_Parent))
                    {y -= 3;DIRECTION_MAX = 35;DIRECTION_Y_MAX = 1*25}
            }
        }
    } 
    else{DIRECTION_MAX = 0;DIRECTION_Y_MAX = 0;}
    // End bridge   
    
    // UP slope
    if (place_meeting(x + sign(_xspd) + (onGround_scale * 1), y , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd) + (onGround_scale * 1), y - 1 , O_Block_Parent) &amp;&amp; !(place_meeting(x + sign(_xspd) + (onGround_scale * 1), y - 2 , O_Block_Parent))) {
        y -= 2;DIRECTION_MAX = 30;DIRECTION_Y_MAX = 1*20;DIRECTION_X_MAX = 30
    } else if (place_meeting(x + sign(_xspd) + (onGround_scale * 1), y , O_Block_Parent) &amp;&amp; !place_meeting(x + sign(_xspd) + (onGround_scale * 1), y - 1 , O_Block_Parent)) {
        --y;DIRECTION_MAX = 25;DIRECTION_Y_MAX = 1*15;DIRECTION_X_MAX = 30
    }
    
    // DOWN slope
    if (!place_meeting(x + sign(_xspd) + (onGround_scale * 1), y , O_Block_Parent) &amp;&amp; !place_meeting(x + sign(_xspd) + (onGround_scale * 1), y + 1 , O_Block_Parent) &amp;&amp; !place_meeting(x + sign(_xspd) + (onGround_scale * 1), y + 2 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd) + (onGround_scale * 1), y + 3 , O_Block_Parent))
        {y += 2;DIRECTION_MAX = 30;DIRECTION_Y_MAX = 1*20;DIRECTION_X_MAX = 30}
    else if (!place_meeting(x + sign(_xspd) + (onGround_scale * 1), y , O_Block_Parent) &amp;&amp; !place_meeting(x + sign(_xspd) + (onGround_scale * 1), y + 1 , O_Block_Parent) &amp;&amp; place_meeting(x + sign(_xspd) + (onGround_scale * 1), y + 2 , O_Block_Parent))
        {++y;DIRECTION_MAX = 25;DIRECTION_Y_MAX = 1*15;DIRECTION_X_MAX = 30}
*/
if (onPlayByEGround)
{
M_FALSE = 0;  
        if x &gt; room_width - sprite_width/2 - (sign(_xspd)*2){
        x -= sign(abs(_xspd))
        }else{
        if x &lt; sprite_width/2 + (sign(_xspd)){
        x += sign(abs(_xspd))
        }           
        else{
        x += sign(_xspd); 
        }
        }
}
else{
    if !(onPlayByGround)
    {      
    M_FALSE = 0;  
        if x &gt; room_width - sprite_width/2 - (sign(_xspd)*2){
        x -= sign(abs(_xspd))
        }else if x &lt; sprite_width/2 + (sign(_xspd) * 2){
        x += sign(abs(_xspd))
        }          
        else{
       if (onGround) || (!(onGround)){ 
        if !instance_place(x+sign(_xspd),y+sign(_yspd) - 1,O_Block_Parent)
        || instance_place(x+sign(_xspd),y+sign(_yspd),oBridgeSegment)
        x += sign(_xspd); 
        //if _Jump &gt;0{x -= (sign(_xspd)/80);}
        
        
        if !(onGround) &amp;&amp; !instance_place(x+sign(_xspd),y+sign(_yspd),oBridgeSegment){
        if _Jump &lt;= 0
        kJump = true;
        }
        
        //if _Jump &gt;0{x -= (sign(_xspd)/80);}
        }
        }
        
        }
    else {
        M_FALSE = 1;
        if !(place_meeting(x + sign(_xspd) + (onGround_scale * 1), y, oBridgeSegment)) {
        x -= sign(_xspd);
        }
        _xspd = 0;
        if _Jump &lt;= 0{
        kJump = true;
        }
        break;
        
    }  
    }
}

if eff_delay == 0 &amp;&amp; _booster &gt; 20{
        eff = instance_create(x,y,O_Player_eff);
        eff.sprite_index = spr_index;
        eff.image_index = img_index;
        eff.image_xscale = xscale;
        eff_delay = 4;
        }else{
        if eff_delay &gt; 0{eff_delay -= 1;}
        }
        /*
if !(place_meeting(x + (onGround_scale * sprite_width/2), y + 30, oBridgeSegment)) {
if DIRECTION_X &gt; 0 &amp;&amp; _ATTACKING &lt;= 0{DIRECTION_X -= 0.5;}
DIRECTION_X_MAX = 0;
}
if DIRECTION_X &lt; DIRECTION_X_MAX{DIRECTION_X += 1;DIRECTION_X_ON = 0;}
if DIRECTION_X &gt; 0{DIRECTION_X_ON = 0;}else{DIRECTION_X_ON = 1;}
if DIRECTION &gt; 0{DIRECTION_ON = 1;}
else 
DIRECTION_ON = 0;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var temp;

// Check if you were onGround previous frame
temp = onGround;
/*
if onGround{
if O_PAD._M_Left == true
onGround_scale = -1;
if O_PAD._M_Right == true
onGround_scale = 1;
}
*/
if _M_Left == true
onGround_scale = -1;
if _M_Right == true
onGround_scale = 1;

onGround = OnGround(onGround_scale);
onWater = OnWater(onGround_scale);
onUpGround = OnUpGround(onGround_scale);

if onWater &amp;&amp; !(_booster &gt; 0){
gravRise    = 0.2//3  * m;
gravFall    = 0.2//3  * m;
gravSlide   = 0.05// * m;
jumpHeight  = 4//25  * m;
jumpHeight_c = jumpHeight;
}else{
gravRise    = 0.6//3  * m;
gravFall    = 0.6//3  * m;
gravSlide   = 0.3// * m;
jumpHeight  = 10//25  * m;
jumpHeight_c = jumpHeight;
}
//if onGround{_yspd = 0};
//onWater = OnWater();
platformTarget = instance_place(x, y + 1/4, O_Block_Parent);

// Squash sprite during jump landing
if (!temp &amp;&amp; onGround) {
    if (_yspd &gt;= 0) {        
        //yscale = 0.66;
        //xscale = 1.33;  
    }
}

if _Damage &gt; 60{
if image_blend == c_white{
image_blend = c_red;
}
if xscale == 1
if rot &lt; 20
rot += 5;

if xscale == -1
if rot &gt; -20
rot -= 5;

_xspd += (0-_xspd)/30;
}else{
if image_blend == c_red{
image_blend = c_white;
}
}

if _attackings &gt; 0 || _Damage &lt;= 60{
rot += (0-rot)/20;
}
if _Damage &gt; 0{_Damage -= 1;}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 이미지 컨트롤 
if spr_index == spr_mx_sprite{img_index_max = 0;img_speed = 0;}
if spr_index == spr_move_sprite || spr_index == spr_move_attack_sprite{
img_index_max = 7;
img_speed = 0.1 * abs(_xspd/2);
}
if spr_index == spr_jump_sprite 
|| spr_index = spr_jump_attack_sprite{
img_index_max = 2;
img_speed = 0.5 * (abs(_yspd/2) + abs(_xspd/2));
}
if spr_index == spr_attack_sprite{img_index_max = 0;img_speed = 0;}

if img_index &lt; img_index_max{
img_index += img_speed;
}
else if img_index &gt;= img_index_max{
img_index = 0;
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// 드로우 
if (_M_Left == true || _M_Right == true) &amp;&amp; (onGround || (onUpGround &amp;&amp; _Jump &lt;= 0))
&amp;&amp; _Down_Jump = 0 &amp;&amp; _Damage &lt;= 60{
if (MyWeapon._attack_Delay &gt; 0 || MyWeapon._attack_Delay_2 &gt; 0 || _attackings &gt; 0){
spr_index = spr_move_attack_sprite;
}
else{
spr_index = spr_move_sprite;
}
}
else if !onGround &amp;&amp; ((abs(_yspd) &gt;= 3 &amp;&amp; (!onUpGround)) || (_Down_Jump = 1))
&amp;&amp; !(MyWeapon._attack_Delay &gt; 0 || MyWeapon._attack_Delay_2 &gt; 0){
if _attackings &gt; 0
spr_index = spr_jump_attack_sprite;
else
spr_index = spr_jump_sprite;
}
else if MyWeapon._attack_Delay &gt; 0 || MyWeapon._attack_Delay_2 &gt; 0{
spr_index = spr_attack_sprite;
}
else if abs(_xspd) &lt; 1 &amp;&amp; (onGround || onUpGround) || _Damage &gt; 60{
if _attackings &gt; 0
spr_index = spr_attack_sprite;
else
spr_index = spr_mx_sprite;
_Down_Jump = 0;
}

if _yspd &lt;= 0 {
_Down_Jump = 0;
}

if _attackings &gt; 0 {
_attackings -= 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>612</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if_variable</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>global.inventory_on</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>-1</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Update relative collision
cLeft  = place_meeting(x - 1, y, O_Block_Parent); 
cRight = place_meeting(x + 1, y, O_Block_Parent); 
cAbove = place_meeting(x, y - 1, O_Block_Parent);
//var kJump = mouse_check_button_pressed(mb_right);
_alp += (1-_alp)/20;
if !collision_rectangle(x-view_wview/2,y-270,x+view_wview/2,y+270,O_Player,1,0){
x = O_Player.x;
y = O_Player.y;
_alp = 0;
if instance_exists(MyWeapon){
MyWeapon.EnTarget = noone;
}
}
if !collision_rectangle(x-sprite_width*1.5,y-270,x+sprite_width*1.5,y+270,O_Player,1,0){
if O_Player.x &gt; x{
_xspd = maxH;m_dir = 1;
_M_Left = false;
_M_Right = true;
}else{
_xspd = -maxH;m_dir = -1;
_M_Left = true;
_M_Right = false;
}
}
else if _booster &lt;= 0{
_M_Left = false;
_M_Right = false;
}


if ((onGround) || (onUpGround &amp;&amp; _yspd &gt;= 0) || onWater) &amp;&amp; _ATTACKING == 0{
if onWater{
if _Jump &gt;0{_moving = 5;_Jump -= 0.4;};
}else{
if _Jump &gt;0{_moving = 5;_Jump -= 4;};}
}
if m_Brake &gt; 0{
if _Jump &lt;=0
_xspd += (0-_xspd)/10;
else
_xspd += (0-_xspd)/20;

if m_Brake &gt;= 30{image_index = 0;}
m_Brake -= 1;
}

if Slide = false &amp;&amp; (_ATTACKING &gt;= 4 || _ATTACKING &lt;= 0) &amp;&amp; _Damage &lt;= 60
{
if (_Jump &gt;= 5){_Jump = 4}
if _M_Left == true{
    m_dir = -1;
    if _moving &lt; 5{_moving +=1;}}
else if _M_Right == true
{
        m_dir = 1;
        if _moving &lt; 5{_moving +=1;}}
else{
if m_Brake &lt;=0{

if _booster &gt; 0 &amp;&amp; _booster &lt; 30{
    _xspd += (0-_xspd)/15;
    
    }
    else if _booster &lt;= 0{
    _xspd = 0;
    if _Jump &lt;= 0{m_dir = 0;}
    }
    }
    if _moving &gt;0{_moving -=1}
    }
}

if instance_exists(MyWeapon){
if instance_exists(MyWeapon.EnTarget){
if MyWeapon.EnTarget.x &gt; x{xscale = 1;}
if MyWeapon.EnTarget.x &lt; x{xscale = -1;}
}else{
if MyWeapon._attack_Delay &lt;= 0 &amp;&amp; MyWeapon._attack_Delay_2 &lt;=0{
if _xspd &gt; 0{xscale = 1;}
if _xspd &lt; 0{xscale = -1;}
}
}
}

if (!onGround &amp;&amp; (cLeft || cRight)){
if MyWeapon._attack_Delay &lt;= 0 &amp;&amp; MyWeapon._attack_Delay_2 &lt;=0{
if (cRight){
xscale = 1;
}
else{
xscale = -1;
}
}
}
else{
Slide = false;
if (!onGround){
    if ((cLeft || cRight) &amp;&amp; _yspd &gt;= 0) {
        // Wall slide
        _yspd = Approach(_yspd, maxV, gravSlide);
    } else {
        
        // Fall normally
        if (_yspd &lt; 0)
            _yspd = Approach(_yspd, maxV, gravRise);
        else
            _yspd = Approach(_yspd, maxV, gravFall);
    }
}
}
if (!((cLeft) &amp;&amp; (cRight))){

if (_M_Left == true || _M_Right == true) &amp;&amp; _booster &lt;= 30 &amp;&amp; m_Brake &lt;= 0 &amp;&amp; _Damage &lt;= 60{
if jumpWidth &lt;=0{
if _xspd &gt; m_dir * maxH &amp;&amp; m_dir == 1{
_xspd -= 1;
}
else if _xspd &lt; m_dir * maxH &amp;&amp; m_dir == -1{
_xspd += 1;
}
else{
_xspd = m_dir * maxH;

}
}else if jumpWidth &gt; 0{
if _xspd &gt; m_dir * maxH &amp;&amp; m_dir == 1{
_xspd -= 1;
}
else if _xspd &lt; m_dir * maxH &amp;&amp; m_dir == -1{
_xspd += 1;
}
else{
_xspd = m_dir * maxH;
}
jumpWidth -= 0.01;
}
}
}
if _booster &gt; 0 &amp;&amp; _Damage &lt;= 60{
if _booster &gt;= 30{
_xspd += ((m_dir * maxH) - _xspd)/10;
}
if _xspd &gt; m_dir * maxH &amp;&amp; m_dir == 1{
}
if _xspd &lt; m_dir * maxH &amp;&amp; m_dir == -1{
}

_booster -= 1;
}
if ((kJump) &amp;&amp; _Jump &lt;= 0 &amp;&amp; _Damage &lt;= 60) || _JumpBlock == 1 {
_Jump = 5;image_speed = 0.6;image_index = 0;
if _Down_Jump == 1 &amp;&amp; _JumpBlock == 0{
y += 1;
}else{
_Down_Jump = 0;
_yspd = -jumpHeight * 1.2;
}
Slide = false;    
m_Brake = 0;
jumpHeight = jumpHeight_c;
_JumpBlock = 0;
kJump = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///test liquid contact

    //find closest liquid box
    var obj  = instance_nearest_bbox(oWater);
    if instance_exists(obj){
    //collide with liquid
    lqd  = place_meeting(x, y, obj) &amp;&amp; !collision_rectangle(bbox_left, y, bbox_right, y + 96, oFloater, true, true) &amp;&amp; !place_meeting(x, y, oShallowWaterMask);
    slqd = place_meeting(x, y, oShallowWaterMask); 
    
    // Jump in water
    if (!slqd) {
    if (lqd != prvlqd) {
            //realise current liquid state
            prvlqd = lqd;
            
            //apply manipulation to liquid
            liquid_apply_force_x(obj, x, _yspd * 0.25);
            liquid_splash_create(obj, x, liquid_point_y(obj, x), -abs(_yspd * 0.5), 16, 8, 8, 0.25, c_white, 0.5, bm_normal);
            
            //speed up on liquid exit/slowdown on entrace
            if (!lqd) _yspd *= 1; else _yspd *= 0.5; 
            
        }
    }
    
    // Jump in shallow water
    if (slqd != sprvlqd)
    {
        //realise current liquid state
        sprvlqd = slqd;
    }    
    
    // Walk in shallow water
    if (slqd) {
        if (_xspd != 0) {
            liquid_apply_force_x(obj, x, _xspd * 0.25);
            if (--splashdelay &lt;= 0) {
                splashdelay = 6;
                liquid_splash_create(obj, x, liquid_point_y(obj, x), -abs(_xspd * 0.25), 4, 4, 4, 0.5, c_white, 0.5, bm_normal); 
            }       
        }
        
        if (_xspd != 0) {
            liquid_apply_force_x(obj, x, _xspd * 0.2);
            liquid_splash_create(obj, x, liquid_point_y(obj, x), -abs(_xspd * 0.2), 4, 4, 4, 0.5, c_white, 0.5, bm_normal);        
        }    
    }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if O_Player._room_start_position == 0{
x = OBJ_NEXT_STAGE.x;
y = OBJ_NEXT_STAGE.y-16;
}
else if O_Player._room_start_position = 1{
x = OBJ_PREVIOUS_STAGE.x;
y = OBJ_PREVIOUS_STAGE.y-16;
}
else if O_Player._room_start_position = 2{
x = OBJ_DOWN_STAGE.x;
y = OBJ_DOWN_STAGE.y-16;
}
else if O_Player._room_start_position = 3{
x = OBJ_UP_STAGE.x;
y = OBJ_UP_STAGE.y-16;
}
else if instance_exists(OBJ_ROOM_START){
x = OBJ_ROOM_START.x;
y = OBJ_ROOM_START.y-16;
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_sprite_ext(spr_index,img_index,x, y,1*xscale, 1, rot, image_blend, image_alpha*_alp);   

//draw_set_font(font0)
//draw_text_colour(x,y,string(onGround_scale),c_red,c_red,c_red,c_red,1);
//draw_text_colour(x,y+30,string(_xspd),c_red,c_red,c_red,c_red,1);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="8">
      <action>
        <libid>1</libid>
        <id>331</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_restart_game</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
